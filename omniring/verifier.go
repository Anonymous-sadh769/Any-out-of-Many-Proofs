package omniring

import (
	"math"
	"math/big"

	"anyOutOfMany/utils"
)

type Verifier struct {
	//Public parameters including generators, commitments, system parameter N and elliptic curve
	u, v                            *big.Int
	Gen_F, Gen_G, Gen_H             utils.Point
	Gen_Vec_G, Gen_Vec_H, Gen_Vec_P []utils.Point
	Gen_Vec_Gw                      []utils.Point // public key vector i.e., ring set
	Pub_Vec_Key                     []utils.Point
	Out_Vec_Coin, Inp_Vec_Coin      []utils.Point
	A, B                            utils.Point // commitments A, B
	T1, T2                          utils.Point // commitments T1, T2, E
	L, R                            []utils.Point

	N int // ring size N
	k int // secret number
	n int // ring size
	d int // maximum width of value

	// challenge values
	w    *big.Int
	y, z *big.Int
	x    *big.Int

	// parameters for response
	C_zeta, C_eta []*big.Int
	tau_x         *big.Int
	mu            *big.Int
	ip            *big.Int

	//Zero Knowledge Proof generated by prover
	Trans Transcript
}

func (verifier *Verifier) New(u *big.Int, v *big.Int, F utils.Point, G utils.Point, H utils.Point, P_Vector []utils.Point, G_Vector []utils.Point, H_Vector []utils.Point, k int, N int, d int) {
	verifier.u = u
	verifier.v = v
	verifier.Gen_F = F
	verifier.Gen_G = G
	verifier.Gen_H = H
	verifier.Gen_Vec_P = P_Vector
	verifier.Gen_Vec_G = G_Vector
	verifier.Gen_Vec_H = H_Vector
	verifier.k = k
	verifier.N = N
	verifier.n = N / k
	verifier.d = d
}

func (verifier *Verifier) ParseZKP() (utils.Point, []utils.Point, []utils.Point) {
	verifier.A = verifier.Trans.A
	verifier.B = verifier.Trans.B
	verifier.T1 = verifier.Trans.T1
	verifier.T2 = verifier.Trans.T2
	verifier.tau_x = verifier.Trans.Tau_x
	verifier.mu = verifier.Trans.Mu
	verifier.C_zeta = verifier.Trans.Zeta
	verifier.C_eta = verifier.Trans.Eta
	verifier.ip = verifier.Trans.Ip
	verifier.L = verifier.Trans.L
	verifier.R = verifier.Trans.R
	verifier.w = verifier.Trans.X
	verifier.x = verifier.Trans.X
	verifier.y = verifier.Trans.Y
	verifier.z = verifier.Trans.Z

	// Check the challenges
	temp_w := Generate_W(verifier.A)
	temp_y, temp_z := Generate_YZ(verifier.A, verifier.B)
	temp_x := Generate_X(verifier.T1, verifier.T2)

	var bit0 bool
	if temp_w.Cmp(verifier.w) != 0 || temp_x.Cmp(verifier.x) != 0 || temp_y.Cmp(verifier.y) != 0 || temp_z.Cmp(verifier.z) != 0 {
		bit0 = false
	}
	_ = bit0

	RHS, Gen_Vec_G, Gen_Vec_H := verifier.Validate()
	return RHS, Gen_Vec_G, Gen_Vec_H
}

func (verifier *Verifier) Validate() (utils.Point, []utils.Point, []utils.Point) {
	// Parameters for Left hand side
	// Generate commitment Y
	Coin_u := utils.Cal_Point_Sca_Vec(verifier.Inp_Vec_Coin, verifier.u) // Coin^u
	Gen_Vec_Y := utils.Cal_Point_Add_Vec(verifier.Pub_Vec_Key, Coin_u)   // Y = Pk \circ Coin^u

	// Generate G_w
	Gw := utils.Commit(verifier.Gen_G, verifier.w)
	Hw := utils.Commit(verifier.Gen_G, verifier.w)
	w_vec := Generate_cons_vec(verifier.n, verifier.w)
	var Gen_Vec_Yw []utils.Point
	for i := 0; i < len(w_vec); i++ {
		Gen_Vec_Yw = append(Gen_Vec_Yw, utils.Commit(Gen_Vec_Y[i], w_vec[i]))
	}
	var temp_point []utils.Point
	temp_point = append(temp_point, Gw)
	temp_point = append(temp_point, Hw)
	temp_point = append(temp_point, Gen_Vec_Yw...)
	temp_point = utils.Cal_Point_Add_Vec(temp_point, verifier.Gen_Vec_P)
	verifier.Gen_Vec_Gw = append(temp_point, verifier.Gen_Vec_G...)

	////////////////////////////////////////////// Compute constraint vectors
	n := verifier.n
	k := verifier.k
	N := verifier.N
	zero_vec := Generate_cons_vec(2+n+N+3*k, big.NewInt(0))
	var vec_v [9][]*big.Int
	for i := 0; i < 9; i++ {
		vec_v[i] = zero_vec
	}
	vec_u4 := zero_vec

	vec_yN := Generate_Exp_Scalar_Vector(verifier.y, N)
	copy(vec_v[0][2+n:2+n+N-1], vec_yN)
	vec_yk := Generate_Exp_Scalar_Vector(verifier.y, k)
	copy(vec_v[1][2+n+N+2*k:2+n+N+3*k-1], vec_yk)
	// no vec_v2
	var vec_yk_1n []*big.Int
	for i := 0; i < k; i++ {
		vec_yk_1n = append(vec_yk_1n, Generate_cons_vec(n, vec_yk[i])...)
	}
	copy(vec_v[3][2+n:2+n+N-1], vec_yk_1n)

	vec_vk := Generate_Exp_Scalar_Vector(verifier.v, verifier.k)
	vec_uvk := utils.Cal_Sca_Vec(vec_vk, verifier.u)
	vec_v[4][0] = big.NewInt(1)
	copy(vec_v[4][2+n+N:2+n+N+k-1], vec_uvk)

	vec_v[5][1] = big.NewInt(1)
	copy(vec_v[5][2+n+N+k:2+n+N+2*k-1], vec_uvk)
	copy(vec_v[5][2+n+N+2*k:2+n+N+3*k-1], vec_vk)

	vec_yn := Generate_Exp_Scalar_Vector(verifier.y, n)
	neg_vec_yn := utils.Cal_Neg_Vec(vec_yn)
	var vec_vk_yn []*big.Int
	for i := 0; i < k; i++ {
		vec_vk_yn = append(vec_vk_yn, utils.Cal_Sca_Vec(vec_yn, vec_vk[i])...)
	}
	copy(vec_v[6][2:2+n-1], neg_vec_yn)
	copy(vec_v[6][2+n:2+n+N], vec_vk_yn)

	neg_vec_1k := Generate_cons_vec(k, big.NewInt(-1))
	copy(vec_v[7][2+n+N:2+n+N+k-1], neg_vec_1k)

	copy(vec_v[8], vec_v[0])

	u2 := utils.Mul_In_P(verifier.u, verifier.u)
	vec_u2vk := utils.Cal_Sca_Vec(vec_vk, u2)
	copy(vec_u4, vec_u2vk)

	vec_theta := zero_vec
	temp := big.NewInt(1)
	for i := 0; i < 2; i++ {
		vec_theta = utils.Cal_Add_Vec(vec_theta, utils.Cal_Sca_Vec(vec_v[i], temp))
		temp = utils.Mul_In_P(temp, verifier.z)
	}

	vec_ksi := zero_vec
	temp = utils.Mul_In_P(verifier.z, verifier.z)
	for i := 2; i < 8; i++ {
		vec_ksi = utils.Cal_Add_Vec(vec_ksi, utils.Cal_Sca_Vec(vec_v[i], temp))
		temp = utils.Mul_In_P(temp, verifier.z)
	}

	vec_mu := zero_vec
	temp = utils.Mul_In_P(verifier.z, verifier.z)
	for i := 2; i < 9; i++ {
		vec_mu = utils.Cal_Add_Vec(vec_mu, utils.Cal_Sca_Vec(vec_v[i], temp))
		temp = utils.Mul_In_P(temp, verifier.z)
	}

	temp = big.NewInt(1) // z^8
	for i := 0; i < 8; i++ {
		temp = utils.Mul_In_P(temp, verifier.z)
	}
	vec_vv := utils.Cal_Sca_Vec(vec_v[8], temp)

	temp = big.NewInt(1) // z^4
	for i := 0; i < 4; i++ {
		temp = utils.Mul_In_P(temp, verifier.z)
	}
	vec_ww := utils.Cal_Sca_Vec(vec_u4, temp)

	vec_inv_theta := utils.Cal_Inv_Vec(vec_theta)
	vec_ww_vv := utils.Cal_Sub_Vec(vec_ww, vec_vv)
	vec_alpha := utils.Cal_HP_Vec(vec_inv_theta, vec_ww_vv)
	vec_beta := utils.Cal_HP_Vec(vec_inv_theta, vec_mu) // Calculated by the verifier, as well as theta and mu

	// Compute Right hand side
	var RHS utils.Point

	// Compute the part in Step (1)
	F_neg_mu := utils.Commit(verifier.Gen_F, utils.Neg_Zp(verifier.mu))
	A_S_x := utils.Cal_Point_Add(verifier.A, utils.Commit(verifier.B, verifier.x))
	Gw_H := utils.Pedersen_Commit_Vector(verifier.Gen_Vec_Gw, verifier.Gen_Vec_H, vec_alpha, vec_beta)
	RHS = utils.Cal_Point_Add(F_neg_mu, A_S_x)
	RHS = utils.Cal_Point_Add(RHS, Gw_H)

	// Compute delta
	vec_1k := Generate_Exp_Scalar_Vector(big.NewInt(1), k)
	delta_1 := utils.Mul_In_P(verifier.z, utils.Mul_In_P(verifier.z, utils.Cal_IP_Vec(vec_1k, vec_yk)))
	vec_1k_1 := append(vec_1k, big.NewInt(1))
	vec_yk_1 := Generate_Exp_Scalar_Vector(verifier.y, k+1)
	z2 := utils.Mul_In_P(verifier.z, verifier.z)
	z3 := utils.Mul_In_P(z2, verifier.z)
	delta_2 := utils.Mul_In_P(z3, utils.Cal_IP_Vec(vec_1k_1, vec_yk_1))
	delta_3 := utils.Cal_IP_Vec(vec_alpha, vec_mu)
	vec_1kN := Generate_Exp_Scalar_Vector(big.NewInt(1), len(verifier.Gen_Vec_Gw))
	delta_4 := utils.Cal_IP_Vec(vec_1kN, vec_vv)
	delta12 := utils.Add_In_P(delta_1, delta_2)
	delta34 := utils.Add_In_P(delta_3, delta_4)
	delta := utils.Add_In_P(delta12, delta34)
	G_delta := utils.Commit(verifier.Gen_G, delta)
	RHS = utils.Cal_Point_Add(RHS, G_delta)

	vec_yk2 := Generate_Exp_Scalar_Vector(verifier.y, len(verifier.Out_Vec_Coin))
	vec_z2_yk2 := utils.Cal_Sca_Vec(vec_yk2, z2)
	Coin_y := utils.Commit_Vector(verifier.Out_Vec_Coin, vec_z2_yk2)

	RHS = utils.Cal_Point_Add(RHS, Coin_y)

	x2 := utils.Mul_In_P(verifier.x, verifier.x)
	T1_T2 := utils.Pedersen_Commit(verifier.T1, verifier.T2, verifier.x, x2)
	RHS = utils.Cal_Point_Add(RHS, T1_T2)

	// Padding the vectors to 2^n length
	deg := math.Ceil(math.Log2(float64(len(verifier.Gen_Vec_Gw))))
	pad := math.Pow(2, deg) - float64(len(verifier.Gen_Vec_Gw))
	zero_vec_pad := Generate_cons_vec(int(pad), big.NewInt(0))
	var one_vec_pad []utils.Point
	for i := 0; i < len(zero_vec_pad); i++ {
		one_vec_pad = append(one_vec_pad, utils.Commit(verifier.Gen_F, big.NewInt(0)))
	}
	verifier.Gen_Vec_Gw = append(verifier.Gen_Vec_Gw, one_vec_pad...)
	verifier.Gen_Vec_H = append(verifier.Gen_Vec_H, one_vec_pad...)

	// bool := opt_verify(verifier.L, verifier.R, RHS, verifier.Gen_Vec_Gw, verifier.Gen_Vec_H, verifier.Gen_G, verifier.c_zeta, verifier.c_eta)

	return RHS, verifier.Gen_Vec_Gw, verifier.Gen_Vec_H
}

// func (verifier *Verifier) checkSk() bool {
// 	// Left hand side
// 	//zeta_yN, _ := utils.Cal_HP_Vec(verifier.zeta, verifier.yN)
// 	LHS := utils.Commit_Vector(verifier.Pub_Vec_Key, verifier.c_zeta, verifier.curve)

// 	// Right hand side
// 	Com_sk := utils.Pedersen_Commit(verifier.Public_ck, verifier.E, verifier.f_s, verifier.x, verifier.curve)
// 	z_yN := utils.Cal_Sca_Vec(verifier.yN, verifier.z)
// 	P_z_yN := utils.Commit_Vector(verifier.Pub_Vec_Key, z_yN, verifier.curve)

// 	var RHS utils.Point
// 	RHS.X, RHS.Y = verifier.curve.Add(Com_sk.X, Com_sk.Y, P_z_yN.X, P_z_yN.Y)

// 	// Check the equation
// 	if utils.Commit_Is_Equal(LHS, RHS) {
// 		fmt.Println("Secret keys are valid!")
// 	} else {
// 		fmt.Println("Secret keys are invalid!")
// 	}
// 	return utils.Commit_Is_Equal(LHS, RHS)
// }

// func (verifier *Verifier) checkIP() bool {
// 	// Right hand side
// 	res, _ := utils.Cal_IP_Vec(verifier.c_zeta, verifier.c_eta)
// 	// Check the equation
// 	if verifier.ip.Cmp(res) == 0 {
// 		fmt.Println("Inner product is valid!")
// 		return true
// 	} else {
// 		fmt.Println("Inner product is invalid!")
// 		return false
// 	}
// }
